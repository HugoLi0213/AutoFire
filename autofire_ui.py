"""Minimal AutoFire Tk GUI for Windows.

Author: Hugo
Last Updated: 2025-10-06

Usage: ``python autofire_ui.py`` (run from an elevated command prompt if
global keyboard hooks require administrator privileges).
The UI lets you choose a trigger key, an output key, the repeat interval
(in milliseconds), and whether the trigger should pass through to other
applications while auto-fire is active. Press *Start* to register the
hooks, hold the trigger key to emit the output at the configured rate,
and use *Stop* or the emergency hotkey (Ctrl+Alt+Esc) to halt.
"""
from __future__ import annotations

import json
import sys
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Optional

import tkinter as tk
from tkinter import messagebox, ttk

CONFIG_PATH = Path(__file__).with_name("autofire.json")
AHK_SCRIPT_PATH = Path(__file__).with_name("autofire.ahk")
MIN_INTERVAL_MS = 1
MAX_INTERVAL_MS = 1000


@dataclass(slots=True)
class AutoFireConfig:
    trigger_key: str = "e"
    output_key: str = "r"
    interval_ms: int = 50
    pass_through: bool = False

    def formatted(self) -> str:
        status = "ON" if self.pass_through else "OFF"
        return (
            f"AutoFire (AHK): {self.trigger_key.upper()}->{self.output_key.upper()} "
            f"@ {self.interval_ms}ms (Pass-through {status})"
        )


class AutoFireEngine:
    def __init__(self, status_callback: Callable[[str, AutoFireConfig], None]) -> None:
        self._config = AutoFireConfig()
        self._status_callback = status_callback
        self._ahk_process: Optional[subprocess.Popen] = None

    @property
    def config(self) -> AutoFireConfig:
        return self._config

    @property
    def is_running(self) -> bool:
        return self._ahk_process is not None and self._ahk_process.poll() is None

    def apply_config(self, config: AutoFireConfig) -> None:
            if config == self._config:
                return
            self.unbind_trigger_handlers()
            self._config = config

    def bind_trigger_handlers(self) -> None:
        self.unbind_trigger_handlers()
        try:
            self._generate_ahk_script()
            self._start_ahk()
            self._update_status("Running (AHK)")
        except Exception as exc:
            raise RuntimeError(f"Unable to start AutoHotkey: {exc}")

    def unbind_trigger_handlers(self) -> None:
        self._stop_ahk()

    def shutdown(self) -> None:
        self.unbind_trigger_handlers()

    def _update_status(self, state: str) -> None:
        self._status_callback(state, self._config)

    # AutoHotkey integration -----------------------------------------------------
    def _generate_ahk_script(self) -> None:
        """Generate autofire.ahk script from current config."""
        # Convert keyboard library key names to AHK key names
        trigger_ahk = self._key_to_ahk(self._config.trigger_key)
        output_ahk = self._key_to_ahk(self._config.output_key)
        pass_through_str = "true" if self._config.pass_through else "false"
        
        script_content = f'''#Requires AutoHotkey v2.0
; Auto-generated by AutoFire - DO NOT EDIT MANUALLY
; This script is automatically updated when you click Start in the AutoFire UI

TriggerKey := "{trigger_ahk}"
OutputKey := "{output_ahk}"
IntervalMs := {self._config.interval_ms}
PassThrough := {pass_through_str}

IsRunning := false

; Emergency stop hotkey (Ctrl+Alt+Esc)
^!Esc::{{
    if (IsRunning) {{
        IsRunning := false
    }}
    ExitApp
}}

; Register trigger key hotkey
if (PassThrough) {{
    ; Pass-through mode: trigger key reaches the game
    Hotkey "~$" TriggerKey, TriggerPress
    Hotkey "~$" TriggerKey " up", TriggerRelease
}} else {{
    ; Block mode: trigger key is suppressed
    Hotkey "$" TriggerKey, TriggerPress
    Hotkey "$" TriggerKey " up", TriggerRelease
}}

TriggerPress(*) {{
    global IsRunning
    if (IsRunning) {{
        return  ; Already running
    }}
    IsRunning := true
    ; Start the autofire loop in a new thread so the hotkey can return
    SetTimer AutoFireLoop, -1
}}

TriggerRelease(*) {{
    global IsRunning
    IsRunning := false
}}

AutoFireLoop() {{
    global IsRunning, OutputKey, IntervalMs
    
    While IsRunning {{
        ; Send the key down
        SendInput "{{" OutputKey " down}}"
        
        ; Wait a random short time (15-45ms) for the "up" stroke to look more human
        r_down_time := Random(15, 45)
        Sleep r_down_time
        
        ; Send the key up
        SendInput "{{" OutputKey " up}}"
        
        ; Wait for the main interval, plus a small random variation (-10ms to +20ms)
        r_interval_variance := Random(-10, 20)
        wait_time := IntervalMs + r_interval_variance
        
        ; Ensure we don't sleep for a negative or tiny amount if interval is low
        if (wait_time < 15) {{
            wait_time := 15
        }}
        Sleep wait_time
    }}
}}
'''
        AHK_SCRIPT_PATH.write_text(script_content, encoding="utf-8")

    def _key_to_ahk(self, key: str) -> str:
        """Convert keyboard library key name to AutoHotkey key name."""
        # Common mappings
        ahk_map = {
            "`": "``",  # Backtick needs escaping
            "esc": "Escape",
            "enter": "Enter",
            "space": "Space",
            "tab": "Tab",
            "backspace": "Backspace",
            "delete": "Delete",
            "insert": "Insert",
            "home": "Home",
            "end": "End",
            "page up": "PgUp",
            "page down": "PgDn",
            "up": "Up",
            "down": "Down",
            "left": "Left",
            "right": "Right",
            "caps lock": "CapsLock",
            "num lock": "NumLock",
            "scroll lock": "ScrollLock",
            "shift": "Shift",
            "ctrl": "Ctrl",
            "alt": "Alt",
            "win": "LWin",
        }
        key_lower = key.lower()
        if key_lower in ahk_map:
            return ahk_map[key_lower]
        # F-keys
        if key_lower.startswith("f") and key_lower[1:].isdigit():
            return key_lower.upper()
        # Single character keys pass through
        return key

    def _start_ahk(self) -> None:
        """Launch the AutoHotkey script."""
        if not AHK_SCRIPT_PATH.exists():
            raise RuntimeError(f"AHK script not found: {AHK_SCRIPT_PATH}")
        
        # Try to find AutoHotkey v2
        ahk_paths = [
            r"C:\\Program Files\\AutoHotkey\\v2\\AutoHotkey64.exe",
            r"C:\\Program Files\\AutoHotkey\\v2\\AutoHotkey32.exe",
            r"C:\\Program Files (x86)\\AutoHotkey\\v2\\AutoHotkey64.exe",
            r"C:\\Program Files (x86)\\AutoHotkey\\v2\\AutoHotkey32.exe",
        ]
        
        ahk_exe = None
        for path in ahk_paths:
            if Path(path).exists():
                ahk_exe = path
                break
        
        if ahk_exe is None:
            raise RuntimeError(
                "AutoHotkey v2 not found. Please install from https://www.autohotkey.com/"
            )
        
        try:
            self._ahk_process = subprocess.Popen(
                [ahk_exe, str(AHK_SCRIPT_PATH)],
                creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0,
            )
        except Exception as exc:
            raise RuntimeError(f"Failed to launch AutoHotkey: {exc}")

    def _stop_ahk(self) -> None:
        """Stop the running AutoHotkey script."""
        if self._ahk_process is None:
            return
        try:
            self._ahk_process.terminate()
            self._ahk_process.wait(timeout=2)
        except Exception:
            try:
                self._ahk_process.kill()
            except Exception:
                pass
        self._ahk_process = None




def load_config() -> AutoFireConfig:
    if not CONFIG_PATH.exists():
        return AutoFireConfig()
    try:
        raw = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON in '{CONFIG_PATH.name}': {exc}") from exc
    except OSError as exc:
        raise ValueError(f"Unable to read '{CONFIG_PATH}': {exc}") from exc
    trigger = raw.get("triggerKey", AutoFireConfig.trigger_key)
    output = raw.get("outputKey", AutoFireConfig.output_key)
    interval = raw.get("intervalMs", AutoFireConfig.interval_ms)
    pass_through = raw.get("passThrough", AutoFireConfig.pass_through)
    return AutoFireConfig(
        trigger_key=str(trigger).strip().lower() if trigger else "e",
        output_key=str(output).strip().lower() if output else "r",
        interval_ms=int(max(MIN_INTERVAL_MS, min(int(interval), MAX_INTERVAL_MS))),
        pass_through=bool(pass_through),
    )


def save_config(config: AutoFireConfig) -> None:
    payload = {
        "triggerKey": config.trigger_key,
        "outputKey": config.output_key,
        "intervalMs": config.interval_ms,
        "passThrough": config.pass_through,
    }
    CONFIG_PATH.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")


class AutoFireUI:
    def __init__(self, root: tk.Tk) -> None:
        self.root = root
        self.root.title("AutoFire")
        self.root.resizable(False, False)
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

        if sys.platform != "win32":
            raise SystemExit("This script is supported on Windows only.")

        self.engine = AutoFireEngine(self._schedule_status_update)
        self._pending_status = "Stopped"
        self._current_config = self.engine.config

        self.trigger_var = tk.StringVar(value=self._current_config.trigger_key)
        self.output_var = tk.StringVar(value=self._current_config.output_key)
        self.interval_var = tk.IntVar(value=self._current_config.interval_ms)
        self.pass_var = tk.BooleanVar(value=self._current_config.pass_through)

        self.status_var = tk.StringVar(value=self._format_status("Stopped", self._current_config))

        self._build_layout()
        self._set_button_states(running=False)
        self.populate_from_config(load_config())

    def _build_layout(self) -> None:
        container = ttk.Frame(self.root, padding=12)
        container.pack(fill=tk.BOTH, expand=True)

        trigger_row = ttk.Frame(container)
        trigger_row.pack(fill=tk.X, pady=4)
        ttk.Label(trigger_row, text="Trigger key").pack(side=tk.LEFT)
        trigger_entry = ttk.Entry(trigger_row, textvariable=self.trigger_var, width=12)
        trigger_entry.pack(side=tk.LEFT, padx=6)
        self.trigger_entry = trigger_entry

        output_row = ttk.Frame(container)
        output_row.pack(fill=tk.X, pady=4)
        ttk.Label(output_row, text="Output key").pack(side=tk.LEFT)
        output_entry = ttk.Entry(output_row, textvariable=self.output_var, width=12)
        output_entry.pack(side=tk.LEFT, padx=6)
        self.output_entry = output_entry

        interval_row = ttk.Frame(container)
        interval_row.pack(fill=tk.X, pady=4)
        ttk.Label(interval_row, text="Interval (ms)").pack(side=tk.LEFT)
        interval_spin = ttk.Spinbox(
            interval_row,
            from_=MIN_INTERVAL_MS,
            to=MAX_INTERVAL_MS,
            textvariable=self.interval_var,
            width=10,
            increment=1,
        )
        interval_spin.pack(side=tk.LEFT, padx=6)
        self.interval_spin = interval_spin

        pass_row = ttk.Frame(container)
        pass_row.pack(fill=tk.X, pady=4)
        pass_check = ttk.Checkbutton(pass_row, text="Pass-through", variable=self.pass_var)
        pass_check.pack(side=tk.LEFT)
        self.pass_check = pass_check

        button_row = ttk.Frame(container)
        button_row.pack(fill=tk.X, pady=10)
        start_btn = ttk.Button(button_row, text="Start", command=start_autofire)
        start_btn.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=3)
        self.start_button = start_btn
        stop_btn = ttk.Button(button_row, text="Stop", command=stop_autofire)
        stop_btn.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=3)
        self.stop_button = stop_btn

        ttk.Label(container, textvariable=self.status_var, relief=tk.SUNKEN, padding=6).pack(fill=tk.X, pady=(8, 0))

        info_text = "Author: Hugo | Last Updated: 2025-10-06"
        ttk.Label(container, text=info_text, foreground="gray").pack(pady=(6, 0))

    def populate_from_config(self, config: AutoFireConfig) -> None:
        self.trigger_var.set(config.trigger_key)
        self.output_var.set(config.output_key)
        self.interval_var.set(config.interval_ms)
        self.pass_var.set(config.pass_through)
        self._current_config = config
        self.engine.apply_config(config)
        self.status_var.set(self._format_status("Stopped", config))
        self._set_button_states(running=False)

    def start(self) -> None:
        self.root.mainloop()

    def on_close(self) -> None:
        stop_autofire()
        self.engine.shutdown()
        self.root.destroy()

    def start_autofire(self) -> None:
        config = self._build_config_from_inputs()
        if config is None:
            return
        save_config(config)
        self.engine.apply_config(config)
        try:
            self.engine.bind_trigger_handlers()
        except RuntimeError as exc:
            messagebox.showerror("AutoFire", str(exc), parent=self.root)
            return
        self._current_config = config
        self.status_var.set(self._format_status("Stopped", config))

    def stop_autofire(self) -> None:
        self.engine.unbind_trigger_handlers()
        self.status_var.set(self._format_status("Stopped", self.engine.config))
        self._set_button_states(running=False)



    def _build_config_from_inputs(self) -> Optional[AutoFireConfig]:
        trigger = self.trigger_var.get().strip().lower()
        output = self.output_var.get().strip().lower()
        if not trigger or not output:
            messagebox.showerror("AutoFire", "Trigger and output keys cannot be empty", parent=self.root)
            return None
        try:
            interval = int(self.interval_var.get())
        except (TypeError, ValueError):
            messagebox.showerror("AutoFire", "Interval must be an integer", parent=self.root)
            return None
        interval = max(MIN_INTERVAL_MS, min(interval, MAX_INTERVAL_MS))
        pass_through = bool(self.pass_var.get())
        return AutoFireConfig(
            trigger_key=trigger,
            output_key=output,
            interval_ms=interval,
            pass_through=pass_through,
        )

    def _schedule_status_update(self, state: str, config: AutoFireConfig) -> None:
        self._pending_status = state
        self._current_config = config
        self.root.after(0, self._flush_status_update)

    def _flush_status_update(self) -> None:
        running = self.engine.is_running
        self._set_button_states(running)
        self.status_var.set(self._format_status(self._pending_status, self._current_config))

    def _set_button_states(self, running: bool) -> None:
        if running:
            self.start_button.configure(state=tk.DISABLED)
            self.stop_button.configure(state=tk.NORMAL)
        else:
            self.start_button.configure(state=tk.NORMAL)
            self.stop_button.configure(state=tk.DISABLED)

    @staticmethod
    def _format_status(state: str, config: AutoFireConfig) -> str:
        if state.startswith("Running"):
            suffix = state
        elif state == "Stopped":
            suffix = "Stopped - Ready"
        else:
            suffix = state
        return f"{config.formatted()} [{suffix}]"


APP: Optional[AutoFireUI] = None


def start_autofire() -> None:
    if APP is None:
        raise RuntimeError("UI has not been initialized")
    APP.start_autofire()


def stop_autofire() -> None:
    if APP is None:
        raise RuntimeError("UI has not been initialized")
    APP.stop_autofire()


def bind_trigger_handlers() -> None:
    if APP is None:
        raise RuntimeError("UI has not been initialized")
    APP.engine.bind_trigger_handlers()


def unbind_trigger_handlers() -> None:
    if APP is None:
        raise RuntimeError("UI has not been initialized")
    APP.engine.unbind_trigger_handlers()


def main() -> None:
    global APP
    root = tk.Tk()
    APP = AutoFireUI(root)
    APP.start()


if __name__ == "__main__":
    main()
